smallInput = `7,1
11,1
11,7
9,7
9,5
2,5
2,3
7,3`;

bigInput = `97839,50187
97839,51418
98477,51418
98477,52600
97593,52600
97593,53826
97775,53826
97775,55054
97845,55054
97845,56233
97465,56233
97465,57483
97608,57483
97608,58579
96811,58579
96811,59852
97008,59852
97008,61033
96717,61033
96717,62334
96880,62334
96880,63489
96457,63489
96457,64646
96051,64646
96051,65657
95227,65657
95227,66837
94921,66837
94921,68027
94622,68027
94622,69047
93911,69047
93911,70060
93212,70060
93212,71120
92635,71120
92635,72596
92849,72596
92849,73389
91754,73389
91754,74603
91423,74603
91423,75740
90939,75740
90939,76321
89599,76321
89599,77746
89534,77746
89534,78350
88294,78350
88294,79381
87652,79381
87652,80751
87413,80751
87413,81696
86631,81696
86631,82560
85757,82560
85757,83382
84844,83382
84844,84206
83940,84206
83940,84858
82877,84858
82877,85750
82046,85750
82046,86260
80883,86260
80883,87208
80098,87208
80098,88347
79444,88347
79444,88713
78195,88713
78195,89333
77149,89333
77149,90043
76167,90043
76167,90587
75078,90587
75078,91641
74294,91641
74294,92071
73137,92071
73137,92508
71993,92508
71993,93110
70937,93110
70937,93943
69982,93943
69982,94328
68818,94328
68818,94683
67646,94683
67646,95050
66484,95050
66484,95138
65231,95138
65231,96310
64331,96310
64331,95940
62951,95940
62951,96391
61818,96391
61818,96987
60710,96987
60710,97190
59505,97190
59505,96879
58213,96879
58213,97722
57119,97722
57119,97166
55819,97166
55819,97745
54666,97745
54666,97742
53448,97742
53448,98007
52246,98007
52246,98267
51034,98267
51034,98470
49810,98470
49810,98262
48588,98262
48588,98022
47376,98022
47376,97624
46185,97624
46185,97999
44929,97999
44929,98024
43692,98024
43692,97280
42567,97280
42567,96960
41393,96960
41393,96827
40185,96827
40185,96238
39079,96238
39079,96684
37717,96684
37717,96571
36476,96571
36476,95754
35447,95754
35447,95464
34260,95464
34260,94960
33148,94960
33148,94733
31928,94733
31928,94380
30749,94380
30749,93612
29754,93612
29754,92588
28902,92588
28902,92325
27680,92325
27680,92040
26449,92040
26449,91353
25438,91353
25438,90516
24525,90516
24525,90387
23155,90387
23155,89486
22287,89486
22287,88416
21558,88416
21558,88164
20219,88164
20219,86821
19735,86821
19735,86167
18705,86167
18705,85155
17987,85155
17987,84913
16550,84913
16550,84073
15658,84073
15658,83006
15003,83006
15003,82108
14180,82108
14180,80918
13697,80918
13697,80382
12440,80382
12440,79182
11992,79182
11992,78337
11092,78337
11092,77091
10750,77091
10750,76233
9854,76233
9854,75223
9177,75223
9177,74226
8474,74226
8474,73087
8018,73087
8018,72269
6957,72269
6957,70795
7182,70795
7182,69951
6125,69951
6125,68563
6271,68563
6271,67731
5101,67731
5101,66547
4778,66547
4778,65200
4955,65200
4955,64241
3978,64241
3978,62979
3960,62979
3960,61794
3701,61794
3701,60765
2769,60765
2769,59574
2468,59574
2468,58225
3049,58225
3049,57049
2747,57049
2747,55867
2442,55867
2442,54643
2487,54643
2487,53478
1841,53478
1841,52227
2406,52227
2406,51018
2473,51018
2473,50174
94582,50174
94582,48596
2009,48596
2009,47397
2365,47397
2365,46143
1843,46143
1843,45001
2683,45001
2683,43797
2775,43797
2775,42479
2160,42479
2160,41424
3205,41424
3205,40171
3106,40171
3106,38868
2869,38868
2869,37745
3423,37745
3423,36645
4010,36645
4010,35554
4580,35554
4580,34404
4951,34404
4951,33049
4777,33049
4777,31917
5239,31917
5239,30850
5852,30850
5852,29916
6735,29916
6735,28754
7113,28754
7113,27735
7780,27735
7780,26320
7728,26320
7728,25544
8824,25544
8824,24250
9045,24250
9045,23184
9655,23184
9655,22440
10732,22440
10732,21595
11633,21595
11633,20324
11970,20324
11970,19659
13085,19659
13085,18479
13572,18479
13572,17583
14400,17583
14400,16906
15457,16906
15457,15867
16133,15867
16133,15383
17351,15383
17351,14556
18228,14556
18228,13309
18750,13309
18750,12641
19780,12641
19780,12253
21017,12253
21017,11069
21646,11069
21646,10560
22777,10560
22777,9597
23598,9597
23598,8853
24576,8853
24576,8780
25951,8780
25951,7864
26827,7864
26827,7601
28063,7601
28063,6935
29084,6935
29084,5913
29952,5913
29952,5397
31065,5397
31065,5302
32347,5302
32347,4647
33404,4647
33404,4202
34545,4202
34545,4010
35768,4010
35768,4073
37052,4073
37052,3941
38266,3941
38266,2861
39255,2861
39255,3369
40606,3369
40606,3042
41773,3042
41773,2609
42929,2609
42929,2225
44105,2225
44105,1748
45283,1748
45283,2332
46557,2332
46557,1675
47738,1675
47738,2385
48979,2385
48979,1804
50188,1804
50188,1737
51411,1737
51411,1988
52623,1988
52623,2448
53808,2448
53808,1826
55089,1826
55089,1951
56310,1951
56310,2824
57415,2824
57415,2496
58705,2496
58705,3475
59750,3475
59750,3658
60944,3658
60944,3202
62312,3202
62312,4128
63319,4128
63319,3826
64685,3826
64685,4784
65652,4784
65652,4734
66966,4734
66966,5412
68012,5412
68012,5604
69257,5604
69257,6711
70095,6711
70095,7060
71271,7060
71271,7843
72230,7843
72230,8110
73464,8110
73464,9092
74296,9092
74296,9127
75698,9127
75698,9689
76793,9689
76793,10879
77456,10879
77456,11732
78331,11732
78331,11970
79675,11970
79675,12644
80703,12644
80703,13616
81482,13616
81482,14818
82035,14818
82035,15485
83066,15485
83066,16276
83987,16276
83987,17268
84703,17268
84703,18250
85418,18250
85418,19090
86290,19090
86290,19787
87349,19787
87349,20771
88066,20771
88066,21986
88463,21986
88463,22781
89434,22781
89434,23591
90412,23591
90412,24650
91025,24650
91025,25931
91254,25931
91254,26923
91962,26923
91962,28166
92198,28166
92198,28940
93359,28940
93359,30162
93623,30162
93623,31247
94173,31247
94173,32499
94314,32499
94314,33454
95216,33454
95216,34580
95692,34580
95692,35889
95596,35889
95596,36999
96114,36999
96114,38116
96649,38116
96649,39319
96857,39319
96857,40464
97338,40464
97338,41631
97767,41631
97767,42884
97695,42884
97695,44173
97221,44173
97221,45292
98160,45292
98160,46525
98102,46525
98102,47740
98289,47740
98289,48979
97634,48979
97634,50187`;

parseRows = inp => inp.split(`\n`).map(x => parseRow(x));
parseRow = inp => {
    return inp.split(`,`).map(x => Number(x));
};


findArea = (c1, c2) => {
    dx = Math.abs(c2[0] - c1[0]) + 1;
    dy = Math.abs(c2[1] - c1[1]) + 1;
    return dx * dy
}

final = inp => {
    const corners = parseRows(inp);

    let biggest = 0;
    corners.forEach((c1, i1) => {
        corners.forEach((c2, i2) => {
            area = findArea(c1, c2)
            if (area > biggest) {
                biggest = area;
            }
        })
    })

    return biggest;
}

// final(smallInput);


// part 2

// showGrid = inp => inp.map(x => x.join(``)).join(`\n`);

// makeInitialGrid = coords => {
//     console.log(coords);
//     const maxX = coords.map(x => x[0]).toSorted((a, b) => b - a)[0] + 2;
//     const maxY = coords.map(x => x[1]).toSorted((a, b) => b - a)[0] + 2;

//     console.log(maxX, maxY);

//     let grid = {};
//     for (let y = 0; y < maxY; y++) {
//         let ymap = {};
//         for (let x = 0; x < maxX; x++) {
//             ymap[x] = '.';
//         }

//         grid[y] = ymap;

//     }
//     console.log(grid);
//     // console.log(showGrid(grid));
//     return grid;
// }

// addOutline = (coords, grid) => {
//     coords.forEach((c, ci) => {
//         grid[c[1]][c[0]] = 'R';
//         addGreenLines(grid, c, coords.at(ci - 1));
//     });
//     // console.log(showGrid(grid));
//     return grid;
// }

// addGreenLines = (grid, c1, c2) => {
//     if (c1[0] === c2[0]) {
//         x = c1[0];
//         c1y = c1[1];
//         c2y = c2[1];
//         ys = c1y > c2y ? [c2y, c1y] : [c1y, c2y];
//         for (let y = ys[0] + 1; y < ys[1]; y++) {
//             grid[y][x] = 'G';
//         }
//     }

//     if (c1[1] === c2[1]) {
//         y = c1[1];
//         c1x = c1[0];
//         c2x = c2[0];
//         xs = c1x > c2x ? [c2x, c1x] : [c1x, c2x];
//         for (let x = xs[0] + 1; x < xs[1]; x++) {
//             grid[y][x] = 'G';
//         }
//     }

//     return grid
// }

// flood = (grid, xi, yi) => {
//     const north = [xi, yi - 1];
//     const northeast = [xi + 1, yi - 1];
//     const northwest = [xi - 1, yi - 1];
//     const south = [xi, yi + 1];
//     const southEast = [xi + 1, yi + 1];
//     const southWest = [xi - 1, yi + 1];
//     const east = [xi + 1, yi];
//     const west = [xi - 1, yi];

//     const adjacent = [
//         north,
//         northeast,
//         northwest,
//         south,
//         southEast,
//         southWest,
//         east,
//         west
//     ];

//     adjacent.forEach(adj => {
//         adjval = grid?.[adj[1]]?.[adj[0]];
//         if (adjval === '.') {
//             grid[adj[1]][adj[0]] = 'w';
//             flood(grid, adj[0], adj[1]);
//         }
//     });

//     return grid;
// }

// floodWhite = grid => {
//     grid = flood(grid, 0, 0);
//     // console.log(showGrid(grid));
//     return grid;
// }

// // floodGreen = grid => {
// //     grid.forEach((row, yi) => {
// //         row.forEach((val, xi) => {
// //             if (val === 'w') {
// //                 grid[yi][xi] = '.';
// //             } else if (val === '.') {
// //                 grid[yi][xi] = 'G';
// //             }
// //         })
// //     });
//     // console.log(showGrid(grid));
// //     return grid;
// // }

// fillGrid = coords => {
//     console.log('init grid')
//     let grid = makeInitialGrid(coords);
//     console.log('addOutline')
//     grid = addOutline(coords, grid);
//     console.log('flood white')
//     grid = floodWhite(grid);
//     // console.log('flood green')
//     // grid = floodGreen(grid);
//     return grid;
// }

// validateTiles = (grid, c1, c2) => {

//     c1y = c1[1];
//     c2y = c2[1];
//     ys = c1y > c2y ? [c2y, c1y] : [c1y, c2y];

//     c1x = c1[0];
//     c2x = c2[0];
//     xs = c1x > c2x ? [c2x, c1x] : [c1x, c2x];

//     for (let y = ys[0] + 1; y < ys[1]; y++) {
//         for (let x = xs[0] + 1; x < xs[1]; x++) {
//             val = grid[y][x];
//             if (val === 'w') {
//                 return false;
//             }
//         }
//     }
//     return true;
// }

// final2 = inp => {
//     console.log('inp', inp);
//     let coords = parseRows(inp);
//     console.log('coords', coords);
//     let grid = fillGrid(coords);
//     // console.log(showGrid(grid));

//     let biggest = 0;
//     coords.forEach((c1, i1) => {
//         coords.forEach((c2, i2) => {
//             area = findArea(c1, c2)
//             if (area > biggest) {
//                 if (validateTiles(grid, c1, c2)) {
//                     biggest = area;
//                 }
//             }
//         })
//     })

//     return biggest;
// }

getGreenBorder = coords => {
    const greens = [];
    coords.forEach((c, ci) => {
        greens.push(getGreenLines(coords.at(ci - 1), c));
    });
    // console.log(showGrid(grid));
    return greens.flat();
}

getGreenLines = (c1, c2) => {
    const greens = [];
    if (c1[0] === c2[0]) {
        x = c1[0];
        c1y = c1[1];
        c2y = c2[1];
        ys = c1y > c2y ? [c2y, c1y] : [c1y, c2y];
        for (let y = ys[0] + 1; y < ys[1]; y++) {
            greens.push([x, y]);
        }
    }

    if (c1[1] === c2[1]) {
        y = c1[1];
        c1x = c1[0];
        c2x = c2[0];
        xs = c1x > c2x ? [c2x, c1x] : [c1x, c2x];
        for (let x = xs[0] + 1; x < xs[1]; x++) {
            greens.push([x, y]);
        }
    }

    return greens;
}



getBorder = (c1, c2) => {
    c1y = c1[1];
    c2y = c2[1];
    ys = c1y > c2y ? [c2y, c1y] : [c1y, c2y];

    c1x = c1[0];
    c2x = c2[0];
    xs = c1x > c2x ? [c2x, c1x] : [c1x, c2x];

    const border = []
    for (let y = ys[0]; y < ys[1]; y++) {
        for (let x = xs[0]; x < xs[1]; x++) {
            if (x === xs[0] || x === xs[1] || y === ys[0] || y === ys[1]) {
                border.push([x, y])
            }
        }
    }
    return border;
}


getIsGreenFill = ([cell, colorMap]) => {
    const row = colorMap.get(cell[1]).toSorted((a, b) => a - b);
    const xcoord = cell[0];


    if (row.includes(xcoord)) {
        return true;
    }

    if (xcoord < row[0] || xcoord > row.at(-1)) {
        return false;
    }

    // console.log('isfill', row, xcoord);

    let green = false;
    let hit = false;
    row.forEach((val, vi) => {
        let prev = row?.[vi - 1];
        let next = row?.[vi + 1];

        if (val !== prev + 1) {
            green = !green;
        }

        if (xcoord > val && xcoord < next) {
            // console.log('here', cell, prev, val, next, green)
            hit = green;
        }

    })

    // console.log('there', cell, hit)
    return hit;
}

memoize = fn => {
    memo = new Map();

    return function (n) {

        if (memo.has(JSON.stringify(n))) {
            return memo.get(JSON.stringify(n));
        }
        result = fn(n);
        memo.set(JSON.stringify(n), result);
        return result;
    }
};

getIsGreenFill = memoize(getIsGreenFill);

validateTiles = (colorMap, c1, c2) => {

    const otherCorner1 = [c1[0], c2[1]]
    const otherCorner2 = [c2[0], c1[1]]

    if (!getIsGreenFill([otherCorner1, colorMap]) || !getIsGreenFill([otherCorner2, colorMap])) {
        return false;
    }


    const border = getBorder(c1, c2);


    // console.log(colorMap);

    let good = true;
    border.forEach(b => {
        if (!getIsGreenFill([b, colorMap])) {
            // console.log('bad', c1, c2, b, colors)
            good = false;
        }
    });
    return good;
}


final2 = inp => {
    let reds = parseRows(inp);
    // console.log('r', reds)
    const greenBorder = getGreenBorder(reds);
    // console.log('gb', greenBorder);

    const colors = reds.concat(greenBorder);
    console.log('length', colors.length);
    const colorMap = new Map();
    colors.forEach((c, ci) => {
        if (colorMap.has(c[1])) {
            curr = colorMap.get(c[1])
            curr.push(c[0]);
        } else {
            colorMap.set(c[1], [c[0]]);
        }
    })

    let biggest = 0;
    reds.forEach((c1, i1) => {
        console.log(i1);
        reds.forEach((c2, i2) => {
            area = findArea(c1, c2)
            if (area > biggest) {
                if (validateTiles(colorMap, c1, c2)) {
                    biggest = area;
                }
            }
        })
    })

    return biggest;
}

final2(bigInput)

// 593696 is too low

// 1624057680 is right
// Set it running before I went to bed,
// This took like an hour and a half to run.
// There's gotta be a better way to optimize this.
// - definitely could optimize by not checking both a/b and b/a rectangles and a/a rectangles, would probably cut time in half.
// But I'm probably not going to.